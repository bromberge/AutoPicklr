#main.py

import asyncio
from datetime import datetime
from fastapi import FastAPI
from sqlmodel import SQLModel, create_engine, Session, select
from models import *
from data import update_candles
from signal_engine import compute_signals
from risk import ensure_wallet, can_open_new_position, size_position
from sim import place_buy, mark_to_market_and_manage
from settings import UNIVERSE, POLL_SECONDS

engine = create_engine("sqlite:///picklr.db", echo=False)

app = FastAPI(title="Picklr SIM")

@app.on_event("startup")
def startup():
    SQLModel.metadata.create_all(engine)
    with Session(engine) as s:
        ensure_wallet(s)

@app.get("/sim")
def sim_status():
    with Session(engine) as s:
        w = s.get(Wallet, 1)
        open_pos = s.exec(select(Position).where(Position.status=="OPEN")).all()
        last_trades = s.exec(select(Trade).order_by(Trade.id.desc())).all()[:10]
        return {
            "wallet_equity_estimate": w.equity_usd if w else None,
            "open_positions": [p.symbol for p in open_pos],
            "recent_trades": [{"sym":t.symbol,"pnl":t.pnl_usd,"res":t.result} for t in last_trades]
        }

@app.get("/orders")
def orders():
    with Session(engine) as s:
        xs = s.exec(select(Order).order_by(Order.id.desc())).all()[:100]
        return [x.__dict__ for x in xs]

@app.get("/positions")
def positions():
    with Session(engine) as s:
        xs = s.exec(select(Position).where(Position.status=="OPEN")).all()
        return [x.__dict__ for x in xs]

@app.get("/trades")
def trades():
    with Session(engine) as s:
        xs = s.exec(select(Trade).order_by(Trade.id.desc())).all()[:200]
        return [x.__dict__ for x in xs]

@app.get("/wallet")
def wallet():
    with Session(engine) as s:
        w = s.get(Wallet, 1)
        return w.__dict__ if w else {}

async def loop():
    await asyncio.sleep(2)
    while True:
        try:
            with Session(engine) as s:
                # 1) fetch minute bars
                await update_candles(s)

                # 2) exit checks / mark-to-market
                mark_to_market_and_manage(s)

                # 3) new entries if room
                if can_open_new_position(s):
                    for sym in UNIVERSE:
                        sigs = compute_signals(s, sym)
                        for sig in sigs:
                            # size & place buy
                            w = s.get(Wallet, 1)
                            qty = size_position(w.balance_usd, sig.entry, sig.stop)
                            if qty <= 0: 
                                continue
                            place_buy(s, sym, qty, sig.entry, sig.reason)
                            break  # one new entry per cycle
        except Exception:
            pass
        await asyncio.sleep(POLL_SECONDS)

@app.on_event("startup")
async def start_loop():
    asyncio.create_task(loop())
